import nltk
from .metrics import predictability as predictability, surprisal as surprisal
from .models import default_model as default_model, sent_predictions as sent_predictions, sliding_window_preds_tagged as sliding_window_preds_tagged
from .utils import get_concreteness_df as get_concreteness_df, get_freq_df as get_freq_df, get_imageability_df as get_imageability_df, mean as mean, slope_coefficient as slope_coefficient, stopwords as stopwords
from _typeshed import Incomplete
from typing import Any, Callable, Generator, Iterable, NamedTuple, Optional, Tuple

TAG_TO_WN: Incomplete
TAGS_OF_INTEREST: Incomplete

class BookReport(NamedTuple):
    title: str
    nwords: Optional[int]
    mean_wl: Optional[float]
    mean_sl: Optional[float]
    mean_tokenspersent: Optional[float]
    prop_contentwords: Optional[float]
    mean_conc: Optional[float]
    mean_img: Optional[float]
    mean_freq: Optional[float]
    prop_pos: Optional[dict]
    surprisal: Iterable | None
    predictability: Iterable | None

class CreativityBenchmark:
    plots_folder: str
    tags: Incomplete
    tags_of_interest: Incomplete
    tag_to_embed: Incomplete
    embed_to_tag: Incomplete
    raw_text: Incomplete
    words: Incomplete
    sents: Incomplete
    tokenized_sents: Incomplete
    tagset: Incomplete
    tagged_sents: Incomplete
    postag_counts: Incomplete
    title: Incomplete
    def __init__(self, raw_text: str, title: str = ..., tagset: str = ...) -> None: ...
    def ngrams(self, n, **kwargs): ...
    def sent_postag_counts(self, tagset: str = ...) -> list[nltk.FreqDist]: ...
    @property
    def tagged_words(self): ...
    def book_postag_counts(self, tagset: Optional[str] = ...) -> nltk.FreqDist: ...
    def num_tokens_per_sentence(self) -> Generator[int, None, None]: ...
    def total_tokens_per_sentence(self) -> int: ...
    def avg_tokens_per_sentence(self) -> float: ...
    def postag_graph(self): ...
    def plot_postag_distribution(self, fig: Incomplete | None = ..., ax: Incomplete | None = ..., **kwargs) -> Tuple[Any, Any]: ...
    def plot_transition_matrix(self) -> None: ...
    def avg_word_length(self): ...
    def avg_sentence_length(self): ...
    def content_words(self): ...
    def content_word_sentlevel(self): ...
    def ncontent_word_sentlevel(self): ...
    def calculate_sent_slopes(self, model, tokenizer, n) -> list[list[float]]: ...
    @property
    def model(self): ...
    @property
    def word2vec_model(self): ...
    def calculate_sim_scores(self, model, tokenizer, sim_function: Callable, max_sents: int = ...): ...
    def predictability(self, n: int, model, tokenizer): ...
    def plot_predictability(self, n, model, tokenizer) -> None: ...
    def sent_lemmas(self) -> list[list[str]]: ...
    def lemmas(self) -> list[str]: ...
    def frequency_ratings(self, lemmas: Optional[list[str]] = ...) -> list[Optional[float]]: ...
    def concreteness_ratings(self, lemmas: Optional[list[str]] = ...) -> list[Optional[float]]: ...
    def imageability_ratings(self, lemmas: Optional[list[str]] = ...) -> list[Optional[float]]: ...
    def report(self, print_time: bool = ..., include_pos: bool = ..., include_llm: bool = ..., n: int = ..., model: Incomplete | None = ..., tokenizer: Incomplete | None = ..., k: int = ..., word2vec_model: Incomplete | None = ...) -> BookReport: ...

    def plot_report(
        self,
        global_dist: BookReport,
        categories: list[str] = ["mean_wl", "mean_sl",
                                 "prop_contentwords", "mean_conc", "mean_img", "mean_freq"],
        **report_args: Any
    ) -> tuple[Any, Any]: ...
